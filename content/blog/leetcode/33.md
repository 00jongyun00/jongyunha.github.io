---
title: Leetcode 33. Search in Rotated Sorted Array
date: 2022-12-04
description: "Advanced binary search"
tags: [Leetcode, Kotlin, Algorithm]
thumbnail: ""
---

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

Example 2:

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

Example 3:
```
Input: nums = [1], target = 0
Output: -1
```
<br/>

## Approach

해당 배열에서 정렬이 꺾이는 구간이 1곳인 것을 주의 깊게 살펴보자.

- start, end, mid 를 정의 한다.
- nums[start] 가 nums[mid] 보다 작으면 start ~ mid 까진 정렬 되어 있다고 가정한다.
- target 이 nums[start] 보다 크거나 같고 nums[mid] 작거나 같으면 start, mid - 1 로 재귀 호출한다.
- target 이 nums[mid] 보다 크거나 같고 nums[end] 보다 작거나 같으면 mid + 1, end 로 재귀 호출 한다.
- 그게 아닌 경우에는 모두 mid + 1, end 로 호출 한다.

```kotlin
fun search(nums: IntArray, target: Int): Int {
    var result = -1

    fun binarySearch(start: Int, end: Int) {
        if (start > end) return
        val mid = (start + end) / 2
        if (nums[mid] == target) {
            result = mid
            return
        }
        if (nums[start] <= nums[mid]) {
            if (target >= nums[start] && target <= nums[mid]) {
                binarySearch(start, mid - 1)
            }
            binarySearch(mid + 1, end)
        }
        if (target >= nums[mid] && target <= nums[end]) {
            binarySearch(mid + 1, end)
        }
        binarySearch(start, mid - 1)
    }
    binarySearch(0, nums.size - 1)
    return result
}
```